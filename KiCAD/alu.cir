** alu **
*
* Electronics Workbench
*
* This file was created by:
*   Multisim to SPICE netlist routine
*
* Generated by: 300195783
* Thursday, July 28 18:20:41, 2022 
* 
*
 

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR10 0 42 virtual_resistanceR10
.subckt virtual_resistanceR10 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

rX10 ZF 42 0.000e+000

rX9 CF 41 0.000e+000

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR9 0 41 virtual_resistanceR9
.subckt virtual_resistanceR9 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

rX6 36 6 0.000e+000

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR6 6 0 virtual_resistanceR6
.subckt virtual_resistanceR6 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR8 8 0 virtual_resistanceR8
.subckt virtual_resistanceR8 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

rX8 38 8 0.000e+000

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR7 7 0 virtual_resistanceR7
.subckt virtual_resistanceR7 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

rX7 37 7 0.000e+000

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR5 5 0 virtual_resistanceR5
.subckt virtual_resistanceR5 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

rX5 35 5 0.000e+000

rX1 31 1 0.000e+000

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR1 1 0 virtual_resistanceR1
.subckt virtual_resistanceR1 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

rX2 32 2 0.000e+000

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR2 2 0 virtual_resistanceR2
.subckt virtual_resistanceR2 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

rX3 33 3 0.000e+000

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR3 3 0 virtual_resistanceR3
.subckt virtual_resistanceR3 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

rX4 34 4 0.000e+000

* !!!BEGIN-INTERACT
*  : delay_factor  ++++i2  ;
*  : setval        ++++f4   ;
*  : ratedval      ++++f6   ;
*  : temp_set      ++++f8   ;
*  : alpha_tc_set  ++++f10  ;
*  : beta_tc_set   ++++f12  ;
*  : tnom_set      ++++f14  ;

*  0        constant  S_OK
*  1e15     constant blown
*  0        VARIABLE Rinit
*  0        VARIABLE cnt
*  1        VARIABLE delaytime
*  0        VARIABLE S_BLOWN
*  0.0      VARIABLE resistance
*  0.0      VARIABLE resrated
*  0.0      VARIABLE restemp
*  0.0      VARIABLE restca
*  0.0      VARIABLE restcb
*  0.0      VARIABLE restnom
*  0.0      VARIABLE tempdiff
*  0.0      VARIABLE tempeffa
*  0.0      VARIABLE tempeffb
*  0.0      VARIABLE tempefft
*  0.0      VARIABLE adjresval
*  0.0      VARIABLE r1Cur
*  0.0      VARIABLE r1TPwr
*  0.0      VARIABLE r1CurAC
*  0.0      VARIABLE r1PwrAC
*  0.0      VARIABLE r1CurDC
*  0.0      VARIABLE r1PwrDC
*  0.0      VARIABLE flag
*  0        VARIABLE nTime
*  0        VARIABLE nTimeCur
*
* : DELAY
*  *delaytime  0 do
*          *cnt 1+ ==>_*cnt
*          *cnt *delaytime =  if
*          *S_BLOWN 1 + ==>_*S_BLOWN
*          0 ==>_*cnt
*          endif
*   loop
*   *S_BLOWN ==>_*animation_state
* ;
*  : R_BLOWN
*        blown resistance GRADUAL_CHANGE_AT_RUN
*  ;
*
* : RESET
*       delay_factor 10000 * ==>_*delaytime
*       setval ==>_*adjresval
*       *adjresval 2.0 f./ ==>_*Rinit
*       ratedval ==>_*resrated
*       temp_set ==>_*restemp
*       alpha_tc_set ==>_*restca
*       beta_tc_set ==>_*restcb
*       tnom_set ==>_*restnom
*       0.0 ==>_*tempdiff
*       0.0 ==>_*tempeffa
*       0.0 ==>_*tempeffb
*       0.0 ==>_*tempefft
*       0.0 ==>_*flag
*       0.0 ==>_*r1TPwr
*       S_OK   ==>_*animation_state
*       0 ==>_*S_BLOWN
*       *Rinit resistance GRADUAL_CHANGE_AT_RUN
*       1 RESET_ACDC
*       2 RESET_ACDC
*       GET_LOCAL_TIME ==>_*nTime
* ;
*  :GRADUAL_CHANGE_AT_RUN locals| ref value |
*       value SET_INSTANCE Resistor ::R r2 resistance
*  ;
*  :BEGIN_PLOT
*       RESET
*  ;
*
*  : ADJUST_RESISTANCE
*      *restemp *restnom f.- ==>_*tempdiff
*      *tempdiff *restca f.* ==>_*tempeffa
*      *tempdiff *tempdiff f.* *restcb f.* ==>_*tempeffb
*      *tempeffa 1.0 f.+ *tempeffb f.+ ==>_*tempefft
*      setval *tempefft f.* ==>_*adjresval
*  ;
*
*  :OUT_DATA
*      1.0 *flag f.> if
*          ADJUST_RESISTANCE
*          GET_INSTANCE Resistor ::R R1 i  ==>_*r1Cur
*          (( *r1Cur )) 1 ADD_ACDC
*          (( *r1Cur )) 2 ADD_ACDC
*          GET_LOCAL_TIME ==>_*nTimeCur
*          *nTimeCur *nTime - 6 >= if
*          (( 1 GET_DC )) ==>_*r1CurDC
*          (( 2 GET_AC )) ==>_*r1CurAC
*          *r1CurDC *r1CurDC f.* *adjresval f.* ==>_*r1PwrDC
*          *r1CurAC *r1CurAC f.* *adjresval f.* ==>_*r1PwrAC
*          *r1PwrDC *r1PwrAC f.+ ==>_*r1TPwr
*          *nTimeCur ==>_*nTime
*          endif
*      ratedval *r1TPwr f.< if
*          1.0 ==>_*flag
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          DELAY
*          R_BLOWN
*     endif
*     endif
*  ;
* : BEGIN_ANALYSIS
*       RESET
*  ;
*
*  1 ACDC::ALLOC_INDEX
*  2 ACDC::ALLOC_INDEX
*
* : SIMULTATION_CHANGED
*      ACDC::CIRCUIT_CHANGE
*      GET_LOCAL_TIME ==>_*nTime
*  ;
*
* !!!END-INTERACT
xR4 4 0 virtual_resistanceR4
.subckt virtual_resistanceR4 1 2
R1 1 3 220/2 pwres TEMP=27
.model pwres r(TC1=0 TC2=0 TNOM=27)
R2 3 2 220/2 
.ends

aU8_C  [14 13] 40 74S08__74S__1
aU8_B  [11 12] 13 74S08__74S__1
aU8_A  [9 10] 14 74S08__74S__1
aU7_D  [dU7.4A dU7.4B] 12 74S02__74S__1
xU7_D.4A 37 dU7.4A VCC GND TTL_SRCV__NON__1

xU7_D.4B 38 dU7.4B VCC GND TTL_SRCV__NON__1

aU7_C  [dU7.3A dU7.3B] 11 74S02__74S__1
xU7_C.3A 35 dU7.3A VCC GND TTL_SRCV__NON__1

xU7_C.3B 36 dU7.3B VCC GND TTL_SRCV__NON__1

aU7_B  [dU7.2A dU7.2B] 10 74S02__74S__1
xU7_B.2A 33 dU7.2A VCC GND TTL_SRCV__NON__1

xU7_B.2B 34 dU7.2B VCC GND TTL_SRCV__NON__1

aU7_A  [dU7.1A dU7.1B] 9 74S02__74S__1
xU7_A.1A 31 dU7.1A VCC GND TTL_SRCV__NON__1

xU7_A.1B 32 dU7.1B VCC GND TTL_SRCV__NON__1

aU6_D  [dU6.4A dU6.4B]
+           [30] 74S86__74S__1
xU6_D.4A SU dU6.4A VCC GND TTL_SRCV__NON__1

xU6_D.4B B_0 dU6.4B VCC GND TTL_SRCV__NON__1

aU6_C  [dU6.3A dU6.3B]
+           [29] 74S86__74S__1
xU6_C.3A SU dU6.3A VCC GND TTL_SRCV__NON__1

xU6_C.3B B_1 dU6.3B VCC GND TTL_SRCV__NON__1

aU6_B  [dU6.2A dU6.2B]
+           [28] 74S86__74S__1
xU6_B.2A SU dU6.2A VCC GND TTL_SRCV__NON__1

xU6_B.2B B_2 dU6.2B VCC GND TTL_SRCV__NON__1

aU6_A  [dU6.1A dU6.1B]
+           [27] 74S86__74S__1
xU6_A.1A SU dU6.1A VCC GND TTL_SRCV__NON__1

xU6_A.1B B_3 dU6.1B VCC GND TTL_SRCV__NON__1

aU5_D  [dU5.4A dU5.4B]
+           [26] 74S86__74S__1
xU5_D.4A SU dU5.4A VCC GND TTL_SRCV__NON__1

xU5_D.4B B_4 dU5.4B VCC GND TTL_SRCV__NON__1

aU5_C  [dU5.3A dU5.3B]
+           [17] 74S86__74S__1
xU5_C.3A SU dU5.3A VCC GND TTL_SRCV__NON__1

xU5_C.3B B_5 dU5.3B VCC GND TTL_SRCV__NON__1

aU5_B  [dU5.2A dU5.2B]
+           [16] 74S86__74S__1
xU5_B.2A SU dU5.2A VCC GND TTL_SRCV__NON__1

xU5_B.2B B_6 dU5.2B VCC GND TTL_SRCV__NON__1

aU5_A  [dU5.1A dU5.1B]
+           [15] 74S86__74S__1
xU5_A.1A SU dU5.1A VCC GND TTL_SRCV__NON__1

xU5_A.1B B_7 dU5.1B VCC GND TTL_SRCV__NON__1

aU4  [dU4.CLK
+      dU4.CLR
+      dU4.M
+      dU4.N
+      dU4.notG1
+      dU4.notG2
+      39
+      40
+      U4_OPEN_3D
+      U4_OPEN_4D]
+     [dU4.1Q
+      dU4.2Q
+      U4_OPEN_3Q
+      U4_OPEN_4Q] 74LS173__74LS__1

xU4.notG2 NOTFI dU4.notG2 VCC GND TTL_LSRCV__NON__1

xU4.1Q dU4.1Q CF VCC GND TTL_LS3S__NON__1

xU4.2Q dU4.2Q ZF VCC GND TTL_LS3S__NON__1

xU4.notG1 NOTFI dU4.notG1 VCC GND TTL_LSRCV__NON__1

xU4.CLR CLR dU4.CLR VCC GND TTL_LSRCV__NON__1

xU4.M 0 dU4.M VCC GND TTL_LSRCV__NON__1

xU4.N 0 dU4.N VCC GND TTL_LSRCV__NON__1

xU4.CLK CLK dU4.CLK VCC GND TTL_LSRCV__NON__1

aU2  [U2_OPEN_C0
+      dU2.A1
+      27
+      dU2.A2
+      28
+      dU2.A3
+      29
+      dU2.A4
+      30]
+     [dU2.SUM_1
+      dU2.SUM_2
+      dU2.SUM_3
+      dU2.SUM_4
+      43] 74LS283__74LS__1

xU2.SUM_4 ~dU2.SUM_4 35 VCC GND TTL_LSDRV__NON__1

xU2.SUM_3 ~dU2.SUM_3 36 VCC GND TTL_LSDRV__NON__1

xU2.SUM_1 ~dU2.SUM_1 38 VCC GND TTL_LSDRV__NON__1

xU2.SUM_2 ~dU2.SUM_2 37 VCC GND TTL_LSDRV__NON__1

xU2.A4 A_0 dU2.A4 VCC GND TTL_LSRCV__NON__1

xU2.A3 A_1 dU2.A3 VCC GND TTL_LSRCV__NON__1

xU2.A2 A_2 dU2.A2 VCC GND TTL_LSRCV__NON__1

xU2.A1 A_3 dU2.A1 VCC GND TTL_LSRCV__NON__1

aU1  [43
+      dU1.A1
+      26
+      dU1.A2
+      17
+      dU1.A3
+      16
+      dU1.A4
+      15]
+     [dU1.SUM_1
+      dU1.SUM_2
+      dU1.SUM_3
+      dU1.SUM_4
+      39] 74LS283__74LS__1

xU1.SUM_4 ~dU1.SUM_4 34 VCC GND TTL_LSDRV__NON__1

xU1.SUM_3 ~dU1.SUM_3 33 VCC GND TTL_LSDRV__NON__1

xU1.SUM_1 ~dU1.SUM_1 31 VCC GND TTL_LSDRV__NON__1

xU1.SUM_2 ~dU1.SUM_2 32 VCC GND TTL_LSDRV__NON__1

xU1.A4 A_7 dU1.A4 VCC GND TTL_LSRCV__NON__1

xU1.A3 A_6 dU1.A3 VCC GND TTL_LSRCV__NON__1

xU1.A2 A_5 dU1.A2 VCC GND TTL_LSRCV__NON__1

xU1.A1 A_4 dU1.A1 VCC GND TTL_LSRCV__NON__1

VCCVCC  VCC 0 dc 5

cC1 VCC 0 1e-007 

aU3 [dU3.notG
+      dU3.DIR
+      rU3.A1
+      rU3.A2
+      rU3.A3
+      rU3.A4
+      rU3.A5
+      rU3.A6
+      rU3.A7
+      rU3.A8
+      25
+      24
+      23
+      22
+      21
+      20
+      19
+      18]
+     [dU3.A1
+      dU3.A2
+      dU3.A3
+      dU3.A4
+      dU3.A5
+      dU3.A6
+      dU3.A7
+      dU3.A8
+      25
+      24
+      23
+      22
+      21
+      20
+      19
+      18] 74LS245__74LS__1

xU3.A3 33 ~dU3.A3  rU3.A3  VCC GND TTL_LSBIDI__NON__1

xU3.A5 35 ~dU3.A5  rU3.A5  VCC GND TTL_LSBIDI__NON__1

xU3.A4 34 ~dU3.A4  rU3.A4  VCC GND TTL_LSBIDI__NON__1

xU3.A6 36 ~dU3.A6  rU3.A6  VCC GND TTL_LSBIDI__NON__1

xU3.A7 37 ~dU3.A7  rU3.A7  VCC GND TTL_LSBIDI__NON__1

xU3.A8 38 ~dU3.A8  rU3.A8  VCC GND TTL_LSBIDI__NON__1

xU3.DIR VCC dU3.DIR VCC GND TTL_LSRCV__NON__1

xU3.A2 32 ~dU3.A2  rU3.A2  VCC GND TTL_LSBIDI__NON__1

xU3.A1 31 ~dU3.A1  rU3.A1  VCC GND TTL_LSBIDI__NON__1

xU3.notG NOTEO dU3.notG VCC GND TTL_LSRCV__NON__1





.MODEL 74S08__74S__1 d_and  ( rise_delay = 7n fall_delay = 7.5n)

.MODEL 74S02__74S__1 d_nor  ( rise_delay = 5.5n fall_delay = 5.5n)

.MODEL 74S86__74S__1 d_chip ( behaviour= "
+; 74S86 QUAD 2-INPUT XOR
+/inputs  A  B
+/outputs  Y
+/table 4
+; A  B   Y
+  L  L   L
+  L  H   H
+  H  L   H
+  H  H   L
+/Conditional_Delay  8
+;event to  condition  output  min/max  time
+  LH    A   (B=L)       Y      max     10.5n
+  HL    A   (B=L)       Y      max     10n
+  LH    A   (B=H)       Y      max     10.5n
+  HL    A   (B=H)       Y      max     10n
+  LH    B   (A=L)       Y      max     10.5n
+  HL    B   (A=L)       Y      max     10n
+  LH    B   (A=H)       Y      max     10.5n
+  HL    B   (A=H)       Y      max     10n
+")

.SUBCKT TTL_SRCV__NON__1 1 2 3 4
* S TTL Load Model 1=input, 2=A/D out, 3=VCC 4=GND
*#L1
aADC1in [1] [2]  ADC1
.MODEL ADC1 adc_bridge (in_low= 2.5 in_high = 2.5 )
*#L1

.ENDS

.SUBCKT TTL_LSRCV__NON__1 1 2 3 4
* LS TTL Load Model 1=input, 2=A/D out, 3=VCC 4=GND
*#L1
aADC1in [1] [2]  ADC1
.MODEL ADC1 adc_bridge (in_low= 2.5 in_high = 2.5 )
*#L1

.ENDS

.SUBCKT TTL_LSDRV__NON__1 1 2 3 4
* LS TTL Active Driver 1=D/A input, 2=output, 3=VCC 4=GND
*#L1
aDAC1in  [1] [2]  DAC1
.MODEL DAC1 dac_bridge  (out_low= 5.0 out_high= 0  out_undef= 0 )
*#L1

.ENDS

.MODEL 74LS283__74LS__1 d_chip ( behaviour= "
+;74LS283   4 BIT FULL ADDER WITH FAST CARRY
+/inputs  C0 A1 B1 A2 B2 A3 B3 A4 B4
+/outputs S1 S2 S3 S4 C4
+/wires W1 W2 W3
+;
+/module IN_83
+/inputs INA INB CIN
+/outputs SUM CARRY
+/table 8
+; A  B CIN  SUM  CARRY
+  L  L  L L  L
+  L  L H H L
+  L H L H L
+  L H H L H
+  H L L H L
+  H L H L H
+  H H L L H
+  H H H H H
+/endmodule
+/instance IN_83 A1 B1 C0 S1 W1
+/instance IN_83 A2 B2 W1 S2 W2
+/instance IN_83 A3 B3 W2 S3 W3
+/instance IN_83 A4 B4 W3 S4 C4
+/delay 45
+;input output rise time fall time
+   C0   S1      24n      24n
+   C0   S2      24n      24n
+   C0   S3      24n      24n
+   C0   S4      24n      24n
+   A1   S1      24n      24n
+   B1   S1      24n      24n
+   A2   S1      24n      24n
+   B2   S1      24n      24n
+   A3   S1      24n      24n
+   B3   S1      24n      24n
+   A4   S1      24n      24n
+   B4   S1      24n      24n
+   A1   S2      24n      24n
+   B1   S2      24n      24n
+   A2   S2      24n      24n
+   B2   S2      24n      24n
+   A3   S2      24n      24n
+   B3   S2      24n      24n
+   A4   S2      24n      24n
+   B4   S2      24n      24n
+   A1   S3      24n      24n
+   B1   S3      24n      24n
+   A2   S3      24n      24n
+   B2   S3      24n      24n
+   A3   S3      24n      24n
+   B3   S3      24n      24n
+   A4   S3      24n      24n
+   B4   S3      24n      24n
+   A1   S4      24n      24n
+   B1   S4      24n      24n
+   A2   S4      24n      24n
+   B2   S4      24n      24n
+   A3   S4      24n      24n
+   B3   S4      24n      24n
+   A4   S4      24n      24n
+   B4   S4      24n      24n
+   C0   C4      17n      22n
+   A1   C4      17n      17n
+   B1   C4      17n      17n
+   A2   C4      17n      17n
+   B2   C4      17n      17n
+   A3   C4      17n      17n
+   B3   C4      17n      17n
+   A4   C4      17n      17n
+   B4   C4      17n      17n
+")

.MODEL 74LS245__74LS__1 d_chip ( behaviour= "
+;74LS245   OCTAL BUS TRANSCEIVER 3-STATE
+/inputs  ~G DIR IA1 IA2 IA3 IA4 IA5 IA6 IA7 IA8 IB1 IB2 IB3 IB4 IB5 IB6 IB7 IB8
+/outputs OA1 OA2 OA3 OA4 OA5 OA6 OA7 OA8 OB1 OB2 OB3 OB4 OB5 OB6 OB7 OB8
+/module BUF_245
+/inputs ~G DIR IA IB
+/outputs OA OB
+/table 3
+;~G DIR  IA IB OA  OB
+  H  X   X  X  Z   Z
+  L  L   X  X  IB  Z
+  L  H   X  X  Z   IA
+/delay 2
+;input output rise time fall time
+   IA    OB       12n      12n
+   IB    OA       12n      12n
+/conditional_delay 8
+;event to   condition output min/max time
+   ZH  ~G    (~G=L)    OA     MAX     40n
+   ZL  ~G    (~G=L)    OA     MAX     40n
+   HZ  ~G    (~G=H)    OA     MAX     25n
+   LZ  ~G    (~G=H)    OA     MAX     28n
+   ZH  ~G    (~G=L)    OB     MAX     40n
+   ZL  ~G    (~G=L)    OB     MAX     40n
+   HZ  ~G    (~G=H)    OB     MAX     25n
+   LZ  ~G    (~G=H)    OB     MAX     28n
+/endmodule
+/instance BUF_245 ~G DIR IA1 IB1 OA1 OB1
+/instance BUF_245 ~G DIR IA2 IB2 OA2 OB2
+/instance BUF_245 ~G DIR IA3 IB3 OA3 OB3
+/instance BUF_245 ~G DIR IA4 IB4 OA4 OB4
+/instance BUF_245 ~G DIR IA5 IB5 OA5 OB5
+/instance BUF_245 ~G DIR IA6 IB6 OA6 OB6
+/instance BUF_245 ~G DIR IA7 IB7 OA7 OB7
+/instance BUF_245 ~G DIR IA8 IB8 OA8 OB8
+")

.SUBCKT TTL_LSBIDI__NON__1 1 2 3 33 44
* LS TTL BIDI Model 1=i/o, 2=digout, 3=digin 33=VCC 44=GND
*  RECEIVER
aADCin [1]  [3] ADC
D21  44  1   D_schottky
D22  25  1   D_schottky
R21  25  33  20K
D23  25  26  D_1N4148
D24  26  44  D_1N4148
* 3 STATE DRIVER
* input  stage
aDACin    [2] [12]    DAC_in
aDACcntl  [2] [13]   DAC_cntl
D6  44 12     D_schottky
D7   5 12     D_schottky
D8   5 13     D_schottky
D9   8 13     D_schottky
R6   5 33     18K
R1   8 33     3K
D1   5  8     D_schottky
Q1   8  5  7  Qideal
R2   6  7     3K
* driver stage
D10 10  8     D_schottky
D2   8 11     D_schottky
Q2  11  8 10  Qideal
R3  44 10     20K
R4   9  7     1.5K
D3   6  9     D_schottky
Q3   9  6  4  Qideal
* output stage
R5  33 11     50
Q4  11 10 1   Qideal
D5   7  1     D_schottky
Q5   1  7 44  Qideal
C1 1 44 1e-12
*
.MODEL D_1N4148 D(Is=100f Rs=16 Cjo=2p Vj=1 Tt=12n M=500m BV=100
+N=1 EG=1.11 XTI=3 KF=0 AF=1 FC=500m IBV=100f TNOM=27)
.MODEL D_schottky D(Is=4n Rs=1 Cjo=4.15f Vj=115m Tt=10p M=156m
+BV=12 N=1.03 EG=650m XTI=2 KF=0 AF=1 FC=200m IBV=5u TNOM=27)
.MODEL Qideal NPN ()
.MODEL ADC adc_bridge (in_low= 0.8 in_high =2.0 rise_delay= 1e-12 fall_delay= 1e-12)
.MODEL DAC_in   dac_bridge (out_low= 0 out_high= 4.5 )
.MODEL DAC_cntl dac_hiz    (out_enabled= 4.5 out_disabled= 0 )
.ENDS

.MODEL 74LS173__74LS__1 d_chip ( behaviour= "
+;74LS173 4 D-TYPE Flip FlopS With Clear
+/inputs  CLK CLR M N ~G1 ~G2 1D 2D 3D 4D
+/outputs 1Q 2Q 3Q 4Q
+/module FF_173
+/inputs CLK CLR M N ~G1 ~G2 D
+/outputs Q
+;clock input_number edge{+|-} number_of_flags sync_entries async_entries
+/clock CLK + 1 3 2
+;SYNC
+;CLK CLR M N ~G1 ~G2 D  F NF
+ X     X X X  H   X  X  X F0
+ X     X X X  X   H  X  X F0
+ X     X X X  L   L  X  X D
+;ASYNC
+;CLK CLR M N ~G1 ~G2 D  F NF
+ X    H  X X  X   X  X  X L
+ X    L  X X  X   X  X  X F0
+/table 4
+;CLK CLR M N ~G1 ~G2  D  F  Q
+ X    X  H H  X   X   X  X  Z
+ X    X  H X  X   X   X  X  Z
+ X    X  X H  X   X   X  X  Z
+ X    X  L L  X   X   X  X  F0
+/delay 2
+;input  output  Rise time  Fall time
+   CLR    Q       X          27n
+   CLK    Q       43n        31n
+/conditional_delay 8
+;event to condition output min/max time
+   ZH  M   (M=L)    Q     MAX     30n
+   ZL  M   (M=L)    Q     MAX     30n
+   HZ  M   (M=H)    Q     MAX     14n
+   LZ  M   (M=H)    Q     MAX     20n
+   ZH  N   (N=L)    Q     MAX     30n
+   ZL  N   (N=L)    Q     MAX     30n
+   HZ  N   (N=H)    Q     MAX     14n
+   LZ  N   (N=H)    Q     MAX     20n
+/constraint 11
+;   Name       Event From  Event To   Min/Max  Time
+ 'PULSE WIDTH'  LH    CLK   HL   CLK    MIN     20n
+ 'PULSE WIDTH'  HL    CLR   LH    CLR    MIN     20n
+ 'SETUP'        HL    D     LH   CLK    MIN     10n
+ 'SETUP'        LH    D     LH   CLK    MIN     10n
+ 'SETUP'        HL   ~G1    LH   CLK    MIN     17n
+ 'SETUP'        HL   ~G2    LH   CLK    MIN     17n
+ 'SETUP'        LH   CLR   LH   CLK    MIN     10n
+ 'HOLD'         LH   CLK    LH   ~G1    MIN      2n
+ 'HOLD'         LH   CLK    LH   ~G2    MIN      2n
+ 'HOLD'         LH   CLK    HL    D     MIN     10n
+ 'HOLD'         LH   CLK    LH    D     MIN     10n
+/endmodule
+/instance  FF_173 CLK CLR M N ~G1 ~G2 1D 1Q
+/instance  FF_173 CLK CLR M N ~G1 ~G2 2D 2Q
+/instance  FF_173 CLK CLR M N ~G1 ~G2 3D 3Q
+/instance  FF_173 CLK CLR M N ~G1 ~G2 4D 4Q
+")

.SUBCKT TTL_LS3S__NON__1 1 2 3 4
* LS TTL 3 State Driver 1=D/A input, 2=output, 3=VCC 4=GND
*#L1
*Ideal 3-state driver model

aDACin   [1] [5] aDAC_in
aDACcntl [1] [6] aDAC_cntl

S1  5 2 6 0  vsw0
Cconverg 2 0 1p

.model vsw0 vswitch (Roff=10MEG Ron=100m Voff=2.5 Von=2.5)
.MODEL aDAC_in   dac_bridge (out_low= 0 out_high = 4.5 out_undef = 2.25)
.MODEL aDAC_cntl dac_hiz    (out_enabled= 5.0 out_disabled = 0)

*#L1


.ENDS


